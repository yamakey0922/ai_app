<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ドキュメント棚入れAIアシスタント</title>
    <!-- 
      ローカルファイルを使用 (プロキシ環境対応)
      以下のファイルが .html と同じフォルダにあることを確認してください:
      1. tailwind.js (https://cdn.tailwindcss.com)
      2. pdf.min.js (https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js)
      3. pdf.worker.min.js (https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js)
      4. jszip.min.js (https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js)
      5. vis-network.min.js (https://cdn.jsdelivr.net/npm/vis-network@9.1.9/standalone/umd/vis-network.min.js)
      6. vis-network.min.css (https://cdn.jsdelivr.net/npm/vis-network@9.1.9/styles/vis-network.min.css)
    -->
    <script src="./tailwind.js"></script>
    <script src="./pdf.min.js"></script>
    <script src="./jszip.min.js"></script>
    <script src="./vis-network.min.js"></script>
    <link rel="stylesheet" href="./vis-network.min.css" type="text/css" />

    <style>
        /* PDF.jsのワーカーパスを設定 */
        :root {
            --pdf-worker-src: './pdf.worker.min.js';
        }
        
        /* ローディングスピナーのアニメーション */
        .loader {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* モーダルのトランジション */
        .modal {
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal .modal-content {
            transition: transform 0.3s ease;
        }
        .modal.invisible {
            visibility: hidden;
        }
        .modal.opacity-0 {
            opacity: 0;
        }
        .modal:not(.invisible):not(.opacity-0) .modal-content {
            transform: scale(1);
        }
        
        /* 確認モーダルのスタイル */
        .confirm-modal-content {
            transition: transform 0.2s ease-out, opacity 0.2s ease-out;
        }

        /* ノード情報のスタイル */
        .node-info-header {
            font-size: 0.95rem;
            font-weight: 600;
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
            color: #1f2937; /* gray-800 */
            border-bottom: 1px solid #e5e7eb; /* gray-200 */
            padding-bottom: 0.25rem;
        }
        .node-info-content {
            font-size: 0.9rem;
            white-space: pre-wrap;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <!-- メインコンテンツ -->
    <div class="w-full max-w-2xl bg-white rounded-xl shadow-lg p-8">
        <h1 class="text-3xl font-bold text-gray-900 mb-6 text-center">ドキュメント棚入れAIアシスタント</h1>

        <!-- API Key Input -->
        <div class="mb-4">
            <label for="apiKey" class="block text-sm font-medium text-gray-700 mb-1">Gemini API Key</label>
            <input type="password" id="apiKey" class="w-full px-4 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="APIキーを入力してください">
        </div>

        <!-- File Upload -->
        <div class="mb-4">
            <label for="fileUpload" class="block text-sm font-medium text-gray-700 mb-1">ドキュメントファイル (最大10件)</label>
            <input type="file" id="fileUpload" 
                   accept=".pdf,.docx,.pptx"
                   multiple 
                   class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer">
            <!-- ★★★ 修正: ファイル名ルールの説明を簡素化 ★★★ -->
            <p class="text-xs text-gray-500 mt-1">
                ファイル名ルール (必須):<br>
                `企画書No_発行年_前フェーズ企画書No_Stage?_カテゴリ_資料名.xxx`<br>
                (Stage1-5, カテゴリA-E)<br>
                (新規の場合は前フェーズNoを `0000`、複数参照は `No1ANDNo2` と表記)
            </p>
        </div>

        <!-- Analyze Button -->
        <div class="flex gap-4">
            <button id="analyzeButton" class="w-full bg-blue-600 text-white font-semibold py-3 px-6 rounded-md shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors duration-200 disabled:opacity-50 disabled:cursor-wait">
                分析を実行
            </button>
            <button id="showNetworkButton" class="w-full bg-gray-700 text-white font-semibold py-3 px-6 rounded-md shadow-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-gray-600 focus:ring-offset-2 transition-colors duration-200 disabled:opacity-50 disabled:cursor-wait">
                関係図を表示
            </button>
        </div>

        <!-- Loading Spinner -->
        <div id="loading" class="hidden items-center justify-center mt-6 p-4 bg-blue-50 rounded-md border border-blue-200">
            <div class="loader w-6 h-6 rounded-full border-4 border-t-4 border-gray-200 mr-3"></div>
            <span id="loadingStatus" class="text-blue-700 font-medium">分析中です...</span>
        </div>

        <!-- Result Display -->
        <div id="resultContainer" class="mt-6 hidden">
            <h2 class="text-xl font-semibold text-gray-800 mb-3">分析結果</h2>
            <div id="resultSummary" class="text-gray-600 mb-2"></div>
            <div id="result" class="bg-gray-50 p-4 rounded-md border border-gray-200 whitespace-pre-wrap text-gray-700 overflow-x-auto">
                <!-- 結果がここに挿入されます -->
            </div>
        </div>
        
        <!-- Error Display -->
        <div id="errorContainer" class="mt-6 hidden">
            <h2 class="text-xl font-semibold text-red-700 mb-3">エラー</h2>
            <div id="error" class="bg-red-50 p-4 rounded-md border border-red-200 whitespace-pre-wrap text-red-800">
                <!-- エラーメッセージがここに挿入されます -->
            </div>
        </div>
    </div>

    <!-- ネットワーク図 表示モーダル -->
    <div id="networkModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 opacity-0 invisible z-50">
        <!-- ★ 修正: max-w-7xl -> max-w-full, h-[90vh] -> h-[95vh] (表示エリア拡大) -->
        <div class="modal-content bg-white rounded-xl shadow-2xl w-full max-w-full h-[95vh] p-6 transform scale-95">
            <!-- モーダルヘッダー -->
            <div class="flex justify-between items-center pb-4 border-b border-gray-200">
                <h2 class="text-2xl font-bold text-gray-800">ドキュメント関係図</h2>
                <button id="closeModalButton" class="text-gray-400 hover:text-gray-600">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            
            <!-- モーダルコンテンツ (図と情報) -->
            <div class="flex flex-col md:flex-row gap-4 pt-4 h-[calc(100%-80px)]">
                <!-- ★ 修正: md:w-2/3 -> md:w-3/4 (グラフエリア拡大) -->
                <div class="w-full md:w-3/4 h-full border border-gray-200 rounded-md relative bg-gray-50">
                    <div id="networkDiagram" class="w-full h-full"></div>
                    <!-- ボタン類 -->
                    <div class="absolute top-2 right-2 flex gap-2">
                        <button id="downloadJPEGButton" class="bg-blue-600 text-white font-medium py-2 px-4 rounded-md shadow hover:bg-blue-700 text-sm transition-colors">
                            JPEGで保存
                        </button>
                        <button id="showDeleteConfirmButton" class="bg-red-100 text-red-700 font-medium py-2 px-4 rounded-md shadow-sm hover:bg-red-200 text-sm transition-colors">
                            履歴を全削除...
                        </button>
                    </div>
                </div>
                
                <!-- ★ 修正: md:w-1/3 -> md:w-1/4 (情報エリア縮小) -->
                <div class="w-full md:w-1/4">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-lg font-semibold">重要ポイント</h3>
                        <button id="downloadInfoButton" 
                                class="bg-green-500 text-white text-sm font-medium py-1 px-3 rounded-md hover:bg-green-600 transition-colors disabled:opacity-50" 
                                disabled title="ノードを選択してください">
                            テキスト保存
                        </button>
                    </div>
                    <div id="nodeInfo" class="bg-gray-50 p-4 rounded-md border border-gray-200 h-full min-h-[50vh] overflow-y-auto">
                        <p class="text-gray-500">ネットワーク図のノードをクリックすると、ここに要約が表示されます。</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 履歴削除 確認モーダル -->
        <div id="deleteConfirmModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center p-4 opacity-0 invisible z-[60]">
            <div class="modal-content confirm-modal-content bg-white rounded-lg shadow-xl p-6 w-full max-w-sm transform scale-95 opacity-0">
                <h3 class="text-lg font-bold text-gray-900 mb-4">履歴の全削除</h3>
                <p class="text-sm text-gray-600 mb-6">
                    本当に保存されている分析履歴をすべて削除しますか？<br>
                    この操作は元に戻せません。
                </p>
                <div class="flex justify-end gap-3">
                    <button id="cancelDeleteButton" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 text-sm font-medium">
                        キャンセル
                    </button>
                    <button id="confirmDeleteButton" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 text-sm font-medium">
                        削除実行
                    </button>
                </div>
            </div>
        </div>
    </div>


    <script type="module">
        // PDF.jsのワーカーパスを設定
        // ★★★ 修正: グローバルスコープの pdfjsLib を window.pdfjsLib で参照 ★★★
        if (typeof window.pdfjsLib !== 'undefined') {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = document.documentElement.style.getPropertyValue('--pdf-worker-src');
        }

        const apiKeyInput = document.getElementById('apiKey');
        const fileUpload = document.getElementById('fileUpload');
        const analyzeButton = document.getElementById('analyzeButton');
        const showNetworkButton = document.getElementById('showNetworkButton');
        
        const loading = document.getElementById('loading');
        const loadingStatus = document.getElementById('loadingStatus');
        
        const resultContainer = document.getElementById('resultContainer');
        const resultSummary = document.getElementById('resultSummary');
        const resultDiv = document.getElementById('result');
        
        const errorContainer = document.getElementById('errorContainer');
        const errorDiv = document.getElementById('error');

        // モーダル関連
        const networkModal = document.getElementById('networkModal');
        const closeModalButton = document.getElementById('closeModalButton');
        const networkDiagramDiv = document.getElementById('networkDiagram');
        const nodeInfoDiv = document.getElementById('nodeInfo');
        const downloadJPEGButton = document.getElementById('downloadJPEGButton');
        const downloadInfoButton = document.getElementById('downloadInfoButton');
        
        // 履歴削除関連
        const showDeleteConfirmButton = document.getElementById('showDeleteConfirmButton');
        const deleteConfirmModal = document.getElementById('deleteConfirmModal');
        const cancelDeleteButton = document.getElementById('cancelDeleteButton');
        const confirmDeleteButton = document.getElementById('confirmDeleteButton');

        let currentNetwork = null; // vis.jsのネットワークインスタンス
        const DB_KEY = 'docAnalysisHistory'; // localStorageのキー

        // --- ライブラリ読み込みチェック ---
        function checkLibraries() {
            // ★★★ 修正: グローバルライブラリを window.xxx でチェック ★★★
            if (typeof window.pdfjsLib !== 'undefined' && typeof window.JSZip !== 'undefined' && typeof window.vis !== 'undefined' && typeof window.tailwind !== 'undefined') {
                console.log("All libraries loaded.");
                analyzeButton.disabled = false;
                showNetworkButton.disabled = false;
                analyzeButton.textContent = "分析を実行";
                showNetworkButton.textContent = "関係図を表示";
                // ★★★ 修正: ライブラリロード後にワーカーパスを再設定 ★★★
                window.pdfjsLib.GlobalWorkerOptions.workerSrc = document.documentElement.style.getPropertyValue('--pdf-worker-src');
            } else {
                console.warn("Waiting for libraries to load... (pdf.js, JSZip, vis.js, tailwind)");
                analyzeButton.disabled = true;
                showNetworkButton.disabled = true;
                analyzeButton.textContent = "ライブラリ読込中...";
                showNetworkButton.textContent = "ライブラリ読込中...";
                setTimeout(checkLibraries, 100); // 100ms後に再チェック
            }
        }
        // ページ読み込み時にチェック開始
        document.addEventListener('DOMContentLoaded', checkLibraries);

        // --- イベントリスナー ---
        analyzeButton.addEventListener('click', handleAnalysis);
        showNetworkButton.addEventListener('click', showNetworkDiagram);
        closeModalButton.addEventListener('click', hideNetworkDiagram);
        downloadJPEGButton.addEventListener('click', downloadNetworkAsJPEG);
        downloadInfoButton.addEventListener('click', downloadNodeInfo);
        
        // 履歴削除ボタン（確認モーダル表示）
        showDeleteConfirmButton.addEventListener('click', () => {
            deleteConfirmModal.classList.remove('invisible', 'opacity-0');
            deleteConfirmModal.querySelector('.modal-content').classList.remove('scale-95', 'opacity-0');
        });

        // 履歴削除（キャンセル）
        cancelDeleteButton.addEventListener('click', () => {
            deleteConfirmModal.classList.add('invisible', 'opacity-0');
            deleteConfirmModal.querySelector('.modal-content').classList.add('scale-95', 'opacity-0');
        });

        // 履歴削除（実行）
        confirmDeleteButton.addEventListener('click', () => {
            localStorage.removeItem(DB_KEY);
            console.log("分析履歴を削除しました。");
            
            // ネットワーク図をクリア
            if (currentNetwork) {
                currentNetwork.destroy();
                currentNetwork = null;
            }
            networkDiagramDiv.innerHTML = '<p class="p-4 text-gray-500">履歴がクリアされました。</p>';
            nodeInfoDiv.innerHTML = '<p class="text-gray-500">ネットワーク図のノードをクリックすると、ここに要約が表示されます。</p>';
            downloadInfoButton.disabled = true;
            
            // 確認モーダルを閉じる
            deleteConfirmModal.classList.add('invisible', 'opacity-0');
            deleteConfirmModal.querySelector('.modal-content').classList.add('scale-95');
        });

        
        // --- 分析実行 (複数ファイル対応) ---
        async function handleAnalysis() {
            const apiKey = apiKeyInput.value;
            const files = fileUpload.files;

            if (!apiKey) {
                showError("APIキーを入力してください。");
                return;
            }
            if (files.length === 0) {
                showError("分析するファイルを選択してください。");
                return;
            }
            if (files.length > 10) {
                showError("一度に分析できるファイルは10件までです。");
                return;
            }

            hideError();
            hideResult();
            showLoading(`ファイル ${files.length}件を処理中...`);

            let successCount = 0;
            let firstSuccessResult = null;
            const analysisPromises = [];

            for (const file of files) {
                analysisPromises.push(
                    processFile(file, apiKey)
                        .then(result => {
                            saveAnalysis(file.name, result);
                            successCount++;
                            if (!firstSuccessResult) {
                                firstSuccessResult = result;
                            }
                        })
                        .catch(err => {
                            console.error(`ファイル ${file.name} の処理に失敗:`, err);
                            // 1件の失敗で全体を止めない
                        })
                );
            }

            try {
                await Promise.all(analysisPromises);
                
                hideLoading();
                
                if (successCount > 0) {
                    const summary = `${files.length}件中 ${successCount}件の分析と保存に成功しました。`;
                    // ★★★ 修正: 最初の結果の100文字程度を表示 ★★★
                    const shortResult = firstSuccessResult.length > 100 
                        ? firstSuccessResult.substring(0, 100) + "..."
                        : firstSuccessResult;
                        
                    showResult(summary, shortResult);
                } else {
                    showError(`${files.length}件すべてのファイル分析に失敗しました。コンソールを確認してください。`);
                }

            } catch (err) { // Promise.all 自体は上のロジックでは失敗しないはずだが念のため
                hideLoading();
                showError(`予期せぬエラーが発生しました: ${err.message}`);
            }
        }

        async function processFile(file, apiKey) {
            loadingStatus.textContent = `ファイル ${file.name} を読み込み中...`;
            console.log(`Processing ${file.name}`);
            
            const text = await extractText(file);
            
            loadingStatus.textContent = `ファイル ${file.name} をGeminiで分析中...`;
            console.log(`Sending text (length: ${text.length}) to Gemini...`);

            const analysisResult = await callGeminiAPI(text, apiKey);
            
            console.log(`Analysis complete for ${file.name}`);
            return analysisResult;
        }

        // --- ファイル処理 ---
        function extractText(file) {
            const extension = file.name.split('.').pop().toLowerCase();
            switch (extension) {
                case 'pdf':
                    return extractTextFromPdf(file);
                case 'docx':
                    return extractTextFromDocx(file);
                case 'pptx':
                    return extractTextFromPptx(file);
                default:
                    throw new Error(`サポートされていないファイル形式です: ${extension}`);
            }
        }

        // --- テキスト抽出 ---
        async function extractTextFromPdf(file) {
            const arrayBuffer = await file.arrayBuffer();
            // ★★★ 修正: グローバルスコープの pdfjsLib を window.pdfjsLib で参照 ★★★
            const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let textContent = '';
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const text = await page.getTextContent();
                textContent += text.items.map(s => s.str).join(' ') + '\n';
            }
            return textContent;
        }

        async function extractTextFromDocx(file) {
            const arrayBuffer = await file.arrayBuffer();
            // ★★★ 修正: グローバルスコープの JSZip を window.JSZip で参照 ★★★
            const zip = await window.JSZip.loadAsync(arrayBuffer);
            const content = await zip.file("word/document.xml").async("string");
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(content, "text/xml");
            const paragraphs = xmlDoc.getElementsByTagName("w:t");
            let textContent = '';
            for (let i = 0; i < paragraphs.length; i++) {
                textContent += paragraphs[i].textContent + ' ';
            }
            return textContent;
        }

        async function extractTextFromPptx(file) {
            const arrayBuffer = await file.arrayBuffer();
            // ★★★ 修正: グローバルスコープの JSZip を window.JSZip で参照 ★★★
            const zip = await window.JSZip.loadAsync(arrayBuffer);
            const slideFiles = [];
            zip.folder("ppt/slides").forEach((relativePath, file) => {
                if (relativePath.startsWith("slide") && relativePath.endsWith(".xml")) {
                    slideFiles.push(`ppt/slides/${relativePath}`);
                }
            });

            let textContent = '';
            for (const slideFile of slideFiles) {
                const content = await zip.file(slideFile).async("string");
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(content, "text/xml");
                const paragraphs = xmlDoc.getElementsByTagName("a:t");
                for (let i = 0; i < paragraphs.length; i++) {
                    textContent += paragraphs[i].textContent + ' ';
                }
                textContent += '\n'; // スライドごとに改行
            }
            return textContent;
        }

        // --- Gemini API ---
        async function callGeminiAPI(text, apiKey) {
            // APIのコンテキスト長を考慮し、テキストを短縮 (約30kトークン制限)
            // 簡易的に文字数で制限 (例: 10万文字)
            const MAX_TEXT_LENGTH = 100000;
            if (text.length > MAX_TEXT_LENGTH) {
                text = text.substring(0, MAX_TEXT_LENGTH) + "... (テキストが長すぎるため省略されました)";
            }

            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{
                    parts: [{
                        text: `以下のドキュメントテキストを分析し、日本語で回答してください。

# ドキュメントテキスト:
${text}

# あなたのタスク:
1.  **内容の要約 (200字程度)**: このドキュメントが何について書かれているかを簡潔に要約してください。
2.  **技術の棚入れ (重要ポイント)**: このドキュメントから得られる重要な知見、技術的なポイント、決定事項などを箇条書きで抽出してください。

# 回答フォーマット (厳守):
【内容の要約 (200字程度)】
ここに要約を記述

【技術の棚入れ (重要ポイント)】
・ここに1つ目のポイントを記述
・ここに2つ目のポイントを記述
・...
`
                    }]
                }]
            };

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.json();
                    throw new Error(`APIリクエスト失敗 (Status: ${response.status}): ${errorBody.error?.message || '不明なエラー'}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates[0].content) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    // Geminiがコンテンツをブロックした場合など
                    const safetyRating = result.candidates?.[0]?.safetyRatings?.[0];
                    if (safetyRating) {
                        throw new Error(`Geminiによってコンテンツがブロックされました (Category: ${safetyRating.category}, Probability: ${safetyRating.probability})`);
                    }
                    throw new Error("APIからの応答が予期した形式ではありません。");
                }
            } catch (error) {
                console.error("Gemini API 呼び出しエラー:", error);
                throw error; // エラーを呼び出し元に伝播させる
            }
        }

        // --- UI制御 ---
        function showLoading(message) {
            loadingStatus.textContent = message;
            loading.classList.remove('hidden');
            loading.classList.add('flex');
            analyzeButton.disabled = true;
            showNetworkButton.disabled = true;
        }

        function hideLoading() {
            loading.classList.add('hidden');
            loading.classList.remove('flex');
            analyzeButton.disabled = false;
            showNetworkButton.disabled = false;
        }

        function showResult(summary, text) {
            resultSummary.textContent = summary;
            resultDiv.textContent = text;
            resultContainer.classList.remove('hidden');
        }

        function hideResult() {
            resultContainer.classList.add('hidden');
        }

        function showError(message) {
            errorDiv.textContent = message;
            errorContainer.classList.remove('hidden');
        }

        function hideError() {
            errorContainer.classList.add('hidden');
        }

        // --- DB (localStorage) 制御 ---
        function loadDatabase() {
            const db = localStorage.getItem(DB_KEY);
            return db ? JSON.parse(db) : [];
        }

        function saveAnalysis(fileName, analysisResult) {
            const db = loadDatabase();
            
            // 既存のデータを検索
            const existingIndex = db.findIndex(item => item.id === fileName);
            
            const newData = {
                id: fileName, // ファイル名をIDとする
                analysis: analysisResult,
                savedAt: new Date().toISOString()
            };

            if (existingIndex > -1) {
                // 既に存在する場合は上書き
                db[existingIndex] = newData;
                console.log(`分析結果を更新しました: ${fileName}`);
            } else {
                // 存在しない場合は追加
                db.push(newData);
                console.log(`分析結果を保存しました: ${fileName}`);
            }
            
            localStorage.setItem(DB_KEY, JSON.stringify(db));
        }

        // --- ネットワーク図 制御 ---

        function showNetworkDiagram() {
            networkModal.classList.remove('invisible', 'opacity-0');
            networkModal.querySelector('.modal-content').classList.remove('scale-95');
            
            // モーダルを開いた瞬間に描画を実行
            // vis.jsはコンテナが表示されている必要があるため
            setTimeout(() => {
                drawNetworkDiagram();
            }, 50); // トランジションを待つ

            // ノード情報エリアをリセット
            nodeInfoDiv.innerHTML = '<p class="text-gray-500">ネットワーク図のノードをクリックすると、ここに要約が表示されます。</p>';
            downloadInfoButton.disabled = true;
            downloadInfoButton.dataset.fileName = "";
        }
        
        function hideNetworkDiagram() {
            networkModal.classList.add('invisible', 'opacity-0');
            networkModal.querySelector('.modal-content').classList.add('scale-95');
        }

        /**
         * ★★★ 修正: ネットワーク図を描画する (グリッドレイアウト、Stage対応) ★★★
         */
        function drawNetworkDiagram() {
            if (currentNetwork) {
                currentNetwork.destroy();
                currentNetwork = null;
            }
            networkDiagramDiv.innerHTML = ''; // クリア

            // ★★★ 修正: window.vis でチェック ★★★
            if (typeof window.vis === 'undefined') {
                console.error("vis.js library is not loaded.");
                networkDiagramDiv.innerHTML = '<p class="p-4 text-red-500">エラー: ネットワークライブラリ(vis.js)の読み込みに失敗しました。</p>';
                return;
            }

            const db = loadDatabase();

            // ★★★ 修正: ソート順を 年 -> Stage (降順) -> カテゴリ -> 企画書No に変更 ★★★
            // Stage (Stage5が上)
            const stageOrder = ['Stage5', 'Stage4', 'Stage3', 'Stage2', 'Stage1', 'Unknown'];
            // カテゴリ (Aが上)
            const categoryOrder = ['A', 'B', 'C', 'D', 'E', 'default', 'error'];

            // ★★★ 修正: ファイル名解析ロジック (db.sort内) - 6要素ルールのみ ★★★
            const parseFileName = (fileName) => {
                const baseName = fileName.substring(0, fileName.lastIndexOf('.')) || fileName;
                const parts = baseName.split('_');
                
                let docId, year, stage, cat;

                if (parts.length >= 6) {
                    // Rule 1: No_年_前No_Stage_カテゴリ_資料名
                    docId = parts[0] || baseName;
                    year = parts[1];
                    stage = parts[3].startsWith('Stage') ? parts[3].trim() : 'Unknown';
                    cat = categoryOrder.includes(parts[4].toUpperCase().trim()) ? parts[4].toUpperCase().trim() : 'default';
                } else {
                    // ルール外
                    docId = parts[0] || baseName;
                    year = 'Unknown';
                    stage = 'Unknown';
                    cat = 'error'; // ルール外は 'error' カテゴリ
                }
                return { docId, year, stage, cat };
            };

            db.sort((a, b) => {
                const infoA = parseFileName(a.id);
                const infoB = parseFileName(b.id);
                
                // 1. 年 (昇順)
                if (infoA.year !== infoB.year) {
                    return infoA.year.localeCompare(infoB.year);
                }
                // 2. Stage (降順)
                if (infoA.stage !== infoB.stage) {
                    return stageOrder.indexOf(infoA.stage) - stageOrder.indexOf(infoB.stage);
                }
                // 3. カテゴリ (昇順)
                if (infoA.cat !== infoB.cat) {
                    return categoryOrder.indexOf(infoA.cat) - categoryOrder.indexOf(infoB.cat);
                }
                // 4. 企画書No (昇順)
                return infoA.docId.localeCompare(infoB.docId);
            });
            // ★★★ ソート処理ここまで ★★★


            if (db.length === 0) {
                networkDiagramDiv.innerHTML = '<p class="p-4 text-gray-500">保存されているデータがありません。</p>';
                return;
            }

            const nodes = [];
            const edges = [];
            
            // X座標: 年 (250px間隔)
            const x_step = 250; 
            // Y座標: Stage (150px間隔)
            const y_stage_step = 150; 
            // Y座標: カテゴリ (100px間隔)
            const y_cat_step = 100;
            
            // X座標計算用のMap
            const yearMap = new Map();
            // 値: { year: string, category: string, stage: string, files: Array<{...}> }
            const analysisMap = new Map();
            
            // 重複ノード（企画書No）のチェック用
            const addedNodes = new Set();
            
            // X軸: 年
            const sortedYears = [...new Set(db.map(item => (item.id.split('_')[1] || 'Unknown')))].sort();
            sortedYears.forEach((year, index) => yearMap.set(year, index));


            // --- 1. ノードデータの集約 (全データをスキャン) ---
            db.forEach(item => {
                const baseName = item.id.substring(0, item.id.lastIndexOf('.')) || item.id;
                const parts = baseName.split('_');
                
                let docId, year, prevDocIdsStr, stage, category;

                // ★★★ 修正: ファイル名ルール解析 (analysisMap作成用) - 6要素ルールのみ ★★★
                if (parts.length >= 6) {
                    // Rule 1: No_年_前No_Stage_カテゴリ_資料名
                    docId = parts[0] || baseName;
                    year = parts[1];
                    prevDocIdsStr = parts[2];
                    stage = parts[3].startsWith('Stage') ? parts[3].trim() : 'Unknown';
                    category = categoryOrder.includes(parts[4].toUpperCase().trim()) ? parts[4].toUpperCase().trim() : 'default';
                } else {
                    // ルール外
                    docId = parts[0] || baseName;
                    year = 'Unknown';
                    prevDocIdsStr = '0000';
                    stage = 'Unknown';
                    category = 'error'; // ルール外は 'error' カテゴリ
                }


                // ★ analysisMap にデータを集約
                if (!analysisMap.has(docId)) {
                    analysisMap.set(docId, {
                        year: year,
                        category: category, // ★ 企画書Noのカテゴリ (最初に見つかったもの)
                        stage: stage,       // ★ 企画書NoのStage (最初に見つかったもの)
                        files: [],
                        prevDocIdsStr: prevDocIdsStr // ★ 企画書Noの親 (最初に見つかったもの)
                    });
                }
                // ファイル情報は、企画書Noに関わらず常に追加
                analysisMap.get(docId).files.push({
                    fileName: item.id,
                    analysis: item.analysis,
                    prevDocIdsStr: prevDocIdsStr // ★ ファイルごとの親
                });
            });

            // --- 2. ノードの作成 (analysisMapから) ---

            // ★★★ 修正: analysisMapのエントリをソート (Y座標計算のため) ★★★
            const sortedNodesData = [...analysisMap.entries()].sort((a, b) => {
                const infoA = a[1]; // data
                const infoB = b[1]; // data
                
                // 1. 年 (昇順)
                if (infoA.year !== infoB.year) {
                    return infoA.year.localeCompare(infoB.year);
                }
                // 2. Stage (降順)
                if (infoA.stage !== infoB.stage) {
                    return stageOrder.indexOf(infoA.stage) - stageOrder.indexOf(infoB.stage);
                }
                // 3. カテゴリ (昇順)
                if (infoA.category !== infoB.category) {
                    return categoryOrder.indexOf(infoA.category) - categoryOrder.indexOf(infoB.category);
                }
                // 4. 企画書No (昇順)
                return a[0].localeCompare(b[0]); // a[0] = docId
            });

            // 同じ (年, Stage, カテゴリ) 内でのYオフセット計算用
            let yCounters = {}; // Key: "x_y_stage_y_cat", Value: count

            sortedNodesData.forEach(([docId, data]) => { // ★ ソート済み配列を使用
                
                // X座標 (年)
                const x_index = yearMap.get(data.year) || 0;
                const x = x_index * x_step;
                
                // Y座標 (Stage + カテゴリ)
                const y_stage_index = stageOrder.indexOf(data.stage);
                const y_stage = y_stage_index * y_stage_step;

                const y_cat_index = categoryOrder.indexOf(data.category);
                const y_category = y_cat_index * y_cat_step;

                // 重なり防止オフセット
                const y_key = `${x_index}_${y_stage_index}_${y_cat_index}`;
                if (!yCounters[y_key]) {
                    yCounters[y_key] = 0;
                }
                // 100px = node height + margin
                const y_offset = yCounters[y_key] * 100; 
                yCounters[y_key]++;

                const y = y_stage + y_category + y_offset;


                const fileTitles = data.files.map(f => f.fileName).join('\n');

                nodes.push({
                    id: docId, // ★ IDは docId (企画書No)
                    // ★★★ 修正: ラベルにカテゴリを追加 ★★★
                    label: `${docId}\n(${data.category} / ${data.stage} / ${data.year})`, 
                    title: fileTitles, // ホバータイトルはファイルリスト
                    group: data.category, // ★ 色分け
                    x: x,  // ★ X座標を指定
                    y: y,  // ★ Y座標を指定
                    fixed: true // ★★★ 修正: fixed: true にして物理エンジンを切る
                });
            });

            // --- 3. エッジの作成 (再度DBをスキャン) ---
            const addedEdges = new Set(); // ★ 重複エッジ防止用

            db.forEach(item => {
                const baseName = item.id.substring(0, item.id.lastIndexOf('.')) || item.id;
                const parts = baseName.split('_');
                
                const currentNodeDocId = parts[0]; // ★ このノードの docId
                let prevDocIdsStr;

                // ★★★ 修正: 前フェーズNoを取得 (6要素ルールのみ) ★★★
                if (parts.length >= 6) { 
                    prevDocIdsStr = parts[2];
                }
                else { 
                    prevDocIdsStr = '0000'; // ルール外は 0000 扱い
                }


                // エッジの追加
                if (prevDocIdsStr !== '0000') {
                    const parentDocIds = prevDocIdsStr.split('AND');
                    parentDocIds.forEach(parentId => {
                        parentId = parentId.trim();
                        if (parentId && analysisMap.has(parentId)) { // 親ノードが存在することを確認
                            const edgeId = `${parentId}->${currentNodeDocId}`;
                            if (!addedEdges.has(edgeId)) { // ★ 重複エッジを追加しない
                                edges.push({
                                    from: parentId,
                                    to: currentNodeDocId,
                                    arrows: "to",
                                    color: { color: '#848484', highlight: '#3498db' },
                                });
                                addedEdges.add(edgeId);
                            }
                        }
                    });
                }
            });

            // --- 4. ネットワークの描画 ---
            const data = { nodes: nodes, edges: edges };
            
            const groupColors = {
                'A': { background: '#FFF59D', border: '#FBC02D' }, // Yellow
                'B': { background: '#A5D6A7', border: '#43A047' }, // Green
                'C': { background: '#90CAF9', border: '#1E88E5' }, // Blue
                'D': { background: '#CE93D8', border: '#8E24AA' }, // Purple
                'E': { background: '#F48FB1', border: '#D81B60' }, // Pink
                'default': { background: '#B0BEC5', border: '#546E7A' }, // Gray
                'error': { background: '#FFAB91', border: '#E64A19' }  // Orange (エラー)
            };

            const options = {
                // ★★★ 修正: physics: false, layout: hierarchical: false ★★★
                physics: false,
                layout: {
                    hierarchical: false
                },
                nodes: {
                    shape: "box",
                    size: 10, // この値は固定だが、ラベルによって幅は変わる
                    margin: 10,
                    font: {
                        size: 14,
                        color: "#333"
                    },
                    borderWidth: 2,
                    shadow: true,
                },
                groups: groupColors, // ★ 色分け
                interaction: {
                    dragNodes: true, // ノードをドラッグ可能にする (レイアウトは崩れる)
                    dragView: true,
                    zoomView: true,
                    hover: true
                },
                edges: {
                    smooth: {
                        type: 'cubicBezier', // ★ 曲線
                        forceDirection: "horizontal", // ★ 横移動（年）を優先
                        roundness: 0.1 // ★ 修正: 0.3 -> 0.1 (より直線的に)
                    },
                    edges: {
                        color: {
                            inherit: false // ★ falseにしないと↑のcolor指定が効かない
                        }
                    }
                }
            };

            // ★★★ 修正: window.vis を使用 ★★★
            currentNetwork = new window.vis.Network(networkDiagramDiv, data, options);

            // ★★★ 修正: ノードクリック時のイベントリスナー (集約対応) ★★★
            currentNetwork.on("click", function(params) {
                if (params.nodes.length > 0) {
                    const nodeId = params.nodes[0];
                    const nodeData = analysisMap.get(nodeId);
                    
                    if (nodeData) {
                        // ノード情報をHTMLとして構築
                        let infoHtml = '';
                        let textToSave = ''; // テキスト保存用

                        nodeData.files.forEach(file => {
                            // 重要ポイントのみを抽出
                            const analysisText = file.analysis;
                            const pointsMatch = analysisText.match(/【技術の棚入れ \(重要ポイント\)】([\s\S]*)/);
                            const importantPoints = pointsMatch ? pointsMatch[1].trim() : '重要ポイントがありません。';

                            infoHtml += `<div class="node-info-block">
                                           <h4 class="node-info-header">${file.fileName}</h4>
                                           <div class="node-info-content">${importantPoints}</div>
                                         </div>`;
                            
                            textToSave += `■ ${file.fileName}\n${importantPoints}\n\n`;
                        });

                        nodeInfoDiv.innerHTML = infoHtml;
                        downloadInfoButton.disabled = false;
                        // ★ テキスト保存用に docId と テキスト内容を保存
                        downloadInfoButton.dataset.fileName = nodeId; 
                        downloadInfoButton.dataset.text = textToSave;

                    } else {
                        nodeInfoDiv.innerHTML = '<p class="text-gray-500">ノード情報の取得に失敗しました。</p>';
                        downloadInfoButton.disabled = true;
                    }
                } else {
                    // ノード以外をクリックした場合はリセット
                    nodeInfoDiv.innerHTML = '<p class="text-gray-500">ネットワーク図のノードをクリックすると、ここに要約が表示されます。</p>';
                    downloadInfoButton.disabled = true;
                }
            });
        }

        // --- JPEGダウンロード / 履歴削除機能 ---
        
        /**
         * ネットワーク図をJPEGとしてダウンロードする
         */
        async function downloadNetworkAsJPEG() {
            if (!currentNetwork) return;

            // 1. vis.jsのcanvasを取得
            const canvas = networkDiagramDiv.querySelector('canvas');
            if (!canvas) {
                console.error("Canvasが見つかりません。");
                return;
            }
            
            // 2. 背景が透明な場合があるため、オフスクリーンCanvasで背景を白に設定
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = canvas.width;
            offscreenCanvas.height = canvas.height;
            const ctx = offscreenCanvas.getContext('2d');
            
            // 背景を白で塗りつぶし
            ctx.fillStyle = '#FFFFFF'; // 白背景
            ctx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            ctx.drawImage(canvas, 0, 0);

            // 3. データURLを取得
            // JPEG形式、品質 0.9 (高画質)
            const dataURL = offscreenCanvas.toDataURL("image/jpeg", 0.9);

            // 4. ダウンロードリンクを作成してクリック
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = 'document_network_diagram.jpeg';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        /**
         * ★★★ 修正: ノード情報のテキスト（重要ポイント）をダウンロードする (集約対応) ★★★
         */
        function downloadNodeInfo() {
            const textToSave = downloadInfoButton.dataset.text;
            const baseFileName = downloadInfoButton.dataset.fileName || "node_info"; // ★ docId が入る
            
            if (!textToSave) {
                console.warn("保存するテキストがありません。");
                return;
            }

            // ファイル名のサニタイズ (簡易)
            let safeFileName = baseFileName.replace(/[^a-z0-9_AND-]/gi, '-');
            
            const fileName = `${safeFileName}_important_points.txt`;

            try {
                const blob = new Blob([textToSave], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            } catch (e) {
                console.error("テキストファイルのダウンロードに失敗しました:", e);
            }
        }

    </script>
</body>
</html>

