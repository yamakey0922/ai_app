<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ドキュメント棚入れAIアシスタント</title>
    <!-- 
      ローカルファイルを使用 (プロキシ環境対応)
      以下のファイルが .html と同じフォルダにあることを確認してください:
      1. tailwind.js (https://cdn.tailwindcss.com)
      2. pdf.min.js (https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js)
      3. pdf.worker.min.js (https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js)
      4. jszip.min.js (https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js)
      5. vis-network.min.js (https://cdn.jsdelivr.net/npm/vis-network@9.1.9/standalone/umd/vis-network.min.js)
      6. vis-network.min.css (https://cdn.jsdelivr.net/npm/vis-network@9.1.9/styles/vis-network.min.css)
    -->
    <script src="./tailwind.js"></script>
    <script src="./pdf.min.js"></script>
    <script src="./jszip.min.js"></script>
    <script src="./vis-network.min.js"></script>
    <link rel="stylesheet" href="./vis-network.min.css" type="text/css" />

    <style>
        /* PDF.jsのワーカーパスを設定 */
        :root {
            --pdf-worker-src: './pdf.worker.min.js';
        }
        
        /* ローディングスピナーのアニメーション */
        .loader {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* モーダルのトランジション */
        .modal {
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal .modal-content {
            transition: transform 0.3s ease;
        }
        .modal.invisible {
            visibility: hidden;
        }
        .modal.opacity-0 {
            opacity: 0;
        }
        .modal:not(.invisible):not(.opacity-0) .modal-content {
            transform: scale(1);
        }
        
        /* 確認モーダルのスタイル */
        .confirm-modal-content {
            transition: transform 0.2s ease-out, opacity 0.2s ease-out;
        }

        /* ノード情報のスタイル */
        .node-info-header {
            font-size: 0.95rem;
            font-weight: 600;
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
            color: #1f2937; /* gray-800 */
            border-bottom: 1px solid #e5e7eb; /* gray-200 */
            padding-bottom: 0.25rem;
        }
        .node-info-content {
            font-size: 0.9rem;
            white-space: pre-wrap;
            margin-bottom: 1rem;
        }

        /* 凡例のスタイル */
        .legend-item {
            display: flex; align-items: center; gap: 8px;
            font-size: 0.85rem; color: #374151;
        }
        .legend-color {
            width: 16px; height: 16px; border: 2px solid #111827; border-radius: 2px;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <!-- メインコンテンツ -->
    <div class="w-full max-w-2xl bg-white rounded-xl shadow-lg p-8">
        <h1 class="text-3xl font-bold text-gray-900 mb-6 text-center">ドキュメント棚入れAIアシスタント</h1>

        <!-- API Key Input -->
        <div class="mb-4">
            <label for="apiKey" class="block text-sm font-medium text-gray-700 mb-1">Gemini API Key</label>
            <input type="password" id="apiKey" class="w-full px-4 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="APIキーを入力してください">
        </div>

        <!-- File Upload -->
        <div class="mb-4">
            <label for="fileUpload" class="block text-sm font-medium text-gray-700 mb-1">ドキュメントファイル (最大10件)</label>
            <input type="file" id="fileUpload" 
                   accept=".pdf,.docx,.pptx"
                   multiple 
                   class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer">
            <p class="text-xs text-gray-500 mt-1">
                ファイル名ルール (必須):<br>
                `企画書No_発行年_前フェーズ企画書No_Stage?_カテゴリ_資料名.xxx`<br>
                (Stage1-5, カテゴリA-E)<br>
                (新規の場合は前フェーズNoを `0000`、複数参照は `No1ANDNo2` と表記)
            </p>
        </div>

        <!-- Analyze Button -->
        <div class="flex gap-4">
            <button id="analyzeButton" class="w-full bg-blue-600 text-white font-semibold py-3 px-6 rounded-md shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors duration-200 disabled:opacity-50 disabled:cursor-wait">
                分析を実行
            </button>
            <button id="showNetworkButton" class="w-full bg-gray-700 text-white font-semibold py-3 px-6 rounded-md shadow-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-gray-600 focus:ring-offset-2 transition-colors duration-200 disabled:opacity-50 disabled:cursor-wait">
                関係図を表示
            </button>
        </div>

        <!-- Loading Spinner -->
        <div id="loading" class="hidden items-center justify-center mt-6 p-4 bg-blue-50 rounded-md border border-blue-200">
            <div class="loader w-6 h-6 rounded-full border-4 border-t-4 border-gray-200 mr-3"></div>
            <span id="loadingStatus" class="text-blue-700 font-medium">分析中です...</span>
        </div>

        <!-- Result Display -->
        <div id="resultContainer" class="mt-6 hidden">
            <h2 class="text-xl font-semibold text-gray-800 mb-3">分析結果</h2>
            <div id="resultSummary" class="text-gray-600 mb-2"></div>
            <div id="result" class="bg-gray-50 p-4 rounded-md border border-gray-200 whitespace-pre-wrap text-gray-700 overflow-x-auto">
                <!-- 結果がここに挿入されます -->
            </div>
        </div>
        
        <!-- Error Display -->
        <div id="errorContainer" class="mt-6 hidden">
            <h2 class="text-xl font-semibold text-red-700 mb-3">エラー</h2>
            <div id="error" class="bg-red-50 p-4 rounded-md border border-red-200 whitespace-pre-wrap text-red-800">
                <!-- エラーメッセージがここに挿入されます -->
            </div>
        </div>
    </div>

    <!-- ネットワーク図 表示モーダル -->
    <div id="networkModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 opacity-0 invisible z-50">
        <div class="modal-content bg-white rounded-xl shadow-2xl w-full max-w-full h-[95vh] p-6 transform scale-95">
            <!-- モーダルヘッダー -->
            <div class="flex justify-between items-center pb-4 border-b border-gray-200">
                <h2 class="text-2xl font-bold text-gray-800">ドキュメント関係図</h2>
                <button id="closeModalButton" class="text-gray-400 hover:text-gray-600" aria-label="Close">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            
            <!-- モーダルコンテンツ (図と情報) -->
            <div class="flex flex-col md:flex-row gap-4 pt-4 h-[calc(100%-80px)]">
                <!-- グラフエリア -->
                <div class="w-full md:w-3/4 h-full border border-gray-200 rounded-md relative bg-gray-50">
                    <div id="networkDiagram" class="w-full h-full"></div>
                    <!-- ボタン類 -->
                    <div class="absolute top-2 right-2 flex gap-2">
                        <button id="downloadJPEGButton" class="bg-blue-600 text-white font-medium py-2 px-4 rounded-md shadow hover:bg-blue-700 text-sm transition-colors">
                            JPEGで保存
                        </button>
                        <button id="showDeleteConfirmButton" class="bg-red-100 text-red-700 font-medium py-2 px-4 rounded-md shadow-sm hover:bg-red-200 text-sm transition-colors">
                            履歴を全削除...
                        </button>
                    </div>

                    <!-- 凡例 -->
                    <div class="absolute bottom-2 left-2 bg-white/90 backdrop-blur rounded-md border border-gray-200 p-2 shadow-sm">
                        <div class="grid grid-cols-3 gap-x-4 gap-y-2">
                            <div class="legend-item"><span class="legend-color" style="background:#FFF59D; border-color:#FBC02D"></span>A</div>
                            <div class="legend-item"><span class="legend-color" style="background:#A5D6A7; border-color:#43A047"></span>B</div>
                            <div class="legend-item"><span class="legend-color" style="background:#90CAF9; border-color:#1E88E5"></span>C</div>
                            <div class="legend-item"><span class="legend-color" style="background:#CE93D8; border-color:#8E24AA"></span>D</div>
                            <div class="legend-item"><span class="legend-color" style="background:#F48FB1; border-color:#D81B60"></span>E</div>
                            <div class="legend-item"><span class="legend-color" style="background:#B0BEC5; border-color:#546E7A"></span>default/error</div>
                        </div>
                    </div>
                </div>
                
                <!-- 情報エリア -->
                <div class="w-full md:w-1/4">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-lg font-semibold">重要ポイント</h3>
                        <button id="downloadInfoButton" 
                                class="bg-green-500 text-white text-sm font-medium py-1 px-3 rounded-md hover:bg-green-600 transition-colors disabled:opacity-50" 
                                disabled title="ノードを選択してください">
                            テキスト保存
                        </button>
                    </div>
                    <div id="nodeInfo" class="bg-gray-50 p-4 rounded-md border border-gray-200 h-full min-h-[50vh] overflow-y-auto">
                        <p class="text-gray-500">ネットワーク図のノードをクリックすると、ここに要約が表示されます。</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 履歴削除 確認モーダル -->
        <div id="deleteConfirmModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center p-4 opacity-0 invisible z-[60]">
            <div class="modal-content confirm-modal-content bg-white rounded-lg shadow-xl p-6 w-full max-w-sm transform scale-95 opacity-0">
                <h3 class="text-lg font-bold text-gray-900 mb-4">履歴の全削除</h3>
                <p class="text-sm text-gray-600 mb-6">
                    本当に保存されている分析履歴をすべて削除しますか？<br>
                    この操作は元に戻せません。
                </p>
                <div class="flex justify-end gap-3">
                    <button id="cancelDeleteButton" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 text-sm font-medium">
                        キャンセル
                    </button>
                    <button id="confirmDeleteButton" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 text-sm font-medium">
                        削除実行
                    </button>
                </div>
            </div>
        </div>
    </div>


    <script type="module">
        // PDF.jsのワーカーパスを設定
        if (typeof window.pdfjsLib !== 'undefined') {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = document.documentElement.style.getPropertyValue('--pdf-worker-src');
        }

        const apiKeyInput = document.getElementById('apiKey');
        const fileUpload = document.getElementById('fileUpload');
        const analyzeButton = document.getElementById('analyzeButton');
        const showNetworkButton = document.getElementById('showNetworkButton');
        
        const loading = document.getElementById('loading');
        const loadingStatus = document.getElementById('loadingStatus');
        
        const resultContainer = document.getElementById('resultContainer');
        const resultSummary = document.getElementById('resultSummary');
        const resultDiv = document.getElementById('result');
        
        const errorContainer = document.getElementById('errorContainer');
        const errorDiv = document.getElementById('error');

        // モーダル関連
        const networkModal = document.getElementById('networkModal');
        const closeModalButton = document.getElementById('closeModalButton');
        const networkDiagramDiv = document.getElementById('networkDiagram');
        const nodeInfoDiv = document.getElementById('nodeInfo');
        const downloadJPEGButton = document.getElementById('downloadJPEGButton');
        const downloadInfoButton = document.getElementById('downloadInfoButton');
        
        // 履歴削除関連
        const showDeleteConfirmButton = document.getElementById('showDeleteConfirmButton');
        const deleteConfirmModal = document.getElementById('deleteConfirmModal');
        const cancelDeleteButton = document.getElementById('cancelDeleteButton');
        const confirmDeleteButton = document.getElementById('confirmDeleteButton');

        let currentNetwork = null; // vis.jsのネットワークインスタンス
        const DB_KEY = 'docAnalysisHistory'; // localStorageのキー

        // --- ライブラリ読み込みチェック ---
        function checkLibraries() {
            if (typeof window.pdfjsLib !== 'undefined' && typeof window.JSZip !== 'undefined' && typeof window.vis !== 'undefined' && typeof window.tailwind !== 'undefined') {
                console.log("All libraries loaded.");
                analyzeButton.disabled = false;
                showNetworkButton.disabled = false;
                analyzeButton.textContent = "分析を実行";
                showNetworkButton.textContent = "関係図を表示";
                window.pdfjsLib.GlobalWorkerOptions.workerSrc = document.documentElement.style.getPropertyValue('--pdf-worker-src');
            } else {
                console.warn("Waiting for libraries to load... (pdf.js, JSZip, vis.js, tailwind)");
                analyzeButton.disabled = true;
                showNetworkButton.disabled = true;
                analyzeButton.textContent = "ライブラリ読込中...";
                showNetworkButton.textContent = "ライブラリ読込中...";
                setTimeout(checkLibraries, 100); // 100ms後に再チェック
            }
        }
        // ページ読み込み時にチェック開始
        document.addEventListener('DOMContentLoaded', checkLibraries);

        // --- イベントリスナー ---
        analyzeButton.addEventListener('click', handleAnalysis);
        showNetworkButton.addEventListener('click', showNetworkDiagram);
        closeModalButton.addEventListener('click', hideNetworkDiagram);
        downloadJPEGButton.addEventListener('click', downloadNetworkAsJPEG);
        downloadInfoButton.addEventListener('click', downloadNodeInfo);
        
        showDeleteConfirmButton.addEventListener('click', () => {
            deleteConfirmModal.classList.remove('invisible', 'opacity-0');
            deleteConfirmModal.querySelector('.modal-content').classList.remove('scale-95', 'opacity-0');
        });

        cancelDeleteButton.addEventListener('click', () => {
            deleteConfirmModal.classList.add('invisible', 'opacity-0');
            deleteConfirmModal.querySelector('.modal-content').classList.add('scale-95', 'opacity-0');
        });

        confirmDeleteButton.addEventListener('click', () => {
            localStorage.removeItem(DB_KEY);
            console.log("分析履歴を削除しました。");
            
            if (currentNetwork) {
                currentNetwork.destroy();
                currentNetwork = null;
            }
            networkDiagramDiv.innerHTML = '<p class="p-4 text-gray-500">履歴がクリアされました。</p>';
            nodeInfoDiv.innerHTML = '<p class="text-gray-500">ネットワーク図のノードをクリックすると、ここに要約が表示されます。</p>';
            downloadInfoButton.disabled = true;
            
            deleteConfirmModal.classList.add('invisible', 'opacity-0');
            deleteConfirmModal.querySelector('.modal-content').classList.add('scale-95');
        });

        
        // --- 分析実行 (複数ファイル対応) ---
        async function handleAnalysis() {
            const apiKey = apiKeyInput.value;
            const files = fileUpload.files;

            if (!apiKey) {
                showError("APIキーを入力してください。");
                return;
            }
            if (files.length === 0) {
                showError("分析するファイルを選択してください。");
                return;
            }
            if (files.length > 10) {
                showError("一度に分析できるファイルは10件までです。");
                return;
            }

            hideError();
            hideResult();
            showLoading(`ファイル ${files.length}件を処理中...`);

            let successCount = 0;
            let firstSuccessResult = null;
            const analysisPromises = [];

            for (const file of files) {
                analysisPromises.push(
                    processFile(file, apiKey)
                        .then(result => {
                            saveAnalysis(file.name, result);
                            successCount++;
                            if (!firstSuccessResult) {
                                firstSuccessResult = result;
                            }
                        })
                        .catch(err => {
                            console.error(`ファイル ${file.name} の処理に失敗:`, err);
                        })
                );
            }

            try {
                await Promise.all(analysisPromises);
                
                hideLoading();
                
                if (successCount > 0) {
                    const summary = `${files.length}件中 ${successCount}件の分析と保存に成功しました。`;
                    const shortResult = firstSuccessResult.length > 100 
                        ? firstSuccessResult.substring(0, 100) + "..."
                        : firstSuccessResult;
                        
                    showResult(summary, shortResult);
                } else {
                    showError(`${files.length}件すべてのファイル分析に失敗しました。コンソールを確認してください。`);
                }

            } catch (err) {
                hideLoading();
                showError(`予期せぬエラーが発生しました: ${err.message}`);
            }
        }

        async function processFile(file, apiKey) {
            loadingStatus.textContent = `ファイル ${file.name} を読み込み中...`;
            console.log(`Processing ${file.name}`);
            
            const text = await extractText(file);
            
            loadingStatus.textContent = `ファイル ${file.name} をGeminiで分析中...`;
            console.log(`Sending text (length: ${text.length}) to Gemini...`);

            const analysisResult = await callGeminiAPI(text, apiKey);
            
            console.log(`Analysis complete for ${file.name}`);
            return analysisResult;
        }

        // --- ファイル処理 ---
        function extractText(file) {
            const extension = file.name.split('.').pop().toLowerCase();
            switch (extension) {
                case 'pdf':
                    return extractTextFromPdf(file);
                case 'docx':
                    return extractTextFromDocx(file);
                case 'pptx':
                    return extractTextFromPptx(file);
                default:
                    throw new Error(`サポートされていないファイル形式です: ${extension}`);
            }
        }

        // --- テキスト抽出 ---
        async function extractTextFromPdf(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let textContent = '';
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const text = await page.getTextContent();
                textContent += text.items.map(s => s.str).join(' ') + '\n';
            }
            return textContent;
        }

        async function extractTextFromDocx(file) {
            const arrayBuffer = await file.arrayBuffer();
            const zip = await window.JSZip.loadAsync(arrayBuffer);
            const content = await zip.file("word/document.xml").async("string");
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(content, "text/xml");
            const paragraphs = xmlDoc.getElementsByTagName("w:t");
            let textContent = '';
            for (let i = 0; i < paragraphs.length; i++) {
                textContent += paragraphs[i].textContent + ' ';
            }
            return textContent;
        }

        async function extractTextFromPptx(file) {
            const arrayBuffer = await file.arrayBuffer();
            const zip = await window.JSZip.loadAsync(arrayBuffer);
            const slideFiles = [];
            zip.folder("ppt/slides").forEach((relativePath, file) => {
                if (relativePath.startsWith("slide") && relativePath.endsWith(".xml")) {
                    slideFiles.push(`ppt/slides/${relativePath}`);
                }
            });

            let textContent = '';
            for (const slideFile of slideFiles) {
                const content = await zip.file(slideFile).async("string");
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(content, "text/xml");
                const paragraphs = xmlDoc.getElementsByTagName("a:t");
                for (let i = 0; i < paragraphs.length; i++) {
                    textContent += paragraphs[i].textContent + ' ';
                }
                textContent += '\n';
            }
            return textContent;
        }

        // --- Gemini API ---
        async function callGeminiAPI(text, apiKey) {
            const MAX_TEXT_LENGTH = 100000;
            if (text.length > MAX_TEXT_LENGTH) {
                text = text.substring(0, MAX_TEXT_LENGTH) + "... (テキストが長すぎるため省略されました)";
            }

            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{
                    parts: [{
                        text: `以下のドキュメントテキストを分析し、日本語で回答してください。

# ドキュメントテキスト:
${text}

# あなたのタスク:
1.  **内容の要約 (500字程度)**: このドキュメントが何について書かれているかを簡潔に要約してください。
2.  **技術の棚入れ (重要ポイント)**: このドキュメントから得られる重要な知見、技術的なポイント、決定事項などを箇条書きで抽出してください。

# 回答フォーマット (厳守):
【内容の要約 (500字程度)】
ここに要約を記述

【技術の棚入れ (重要ポイント)】
・ここに1つ目のポイントを記述
・ここに2つ目のポイントを記述
・...
`
                    }]
                }]
            };

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.json();
                    throw new Error(`APIリクエスト失敗 (Status: ${response.status}): ${errorBody.error?.message || '不明なエラー'}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates[0].content) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    const safetyRating = result.candidates?.[0]?.safetyRatings?.[0];
                    if (safetyRating) {
                        throw new Error(`Geminiによってコンテンツがブロックされました (Category: ${safetyRating.category}, Probability: ${safetyRating.probability})`);
                    }
                    throw new Error("APIからの応答が予期した形式ではありません。");
                }
            } catch (error) {
                console.error("Gemini API 呼び出しエラー:", error);
                throw error;
            }
        }

        // --- UI制御 ---
        function showLoading(message) {
            loadingStatus.textContent = message;
            loading.classList.remove('hidden');
            loading.classList.add('flex');
            analyzeButton.disabled = true;
            showNetworkButton.disabled = true;
        }

        function hideLoading() {
            loading.classList.add('hidden');
            loading.classList.remove('flex');
            analyzeButton.disabled = false;
            showNetworkButton.disabled = false;
        }

        function showResult(summary, text) {
            resultSummary.textContent = summary;
            resultDiv.textContent = text;
            resultContainer.classList.remove('hidden');
        }

        function hideResult() {
            resultContainer.classList.add('hidden');
        }

        function showError(message) {
            errorDiv.textContent = message;
            errorContainer.classList.remove('hidden');
        }

        function hideError() {
            errorContainer.classList.add('hidden');
        }

        // --- DB (localStorage) 制御 ---
        function loadDatabase() {
            const db = localStorage.getItem(DB_KEY);
            return db ? JSON.parse(db) : [];
        }

        function saveAnalysis(fileName, analysisResult) {
            const db = loadDatabase();
            
            const existingIndex = db.findIndex(item => item.id === fileName);
            
            const newData = {
                id: fileName,
                analysis: analysisResult,
                savedAt: new Date().toISOString()
            };

            if (existingIndex > -1) {
                db[existingIndex] = newData;
                console.log(`分析結果を更新しました: ${fileName}`);
            } else {
                db.push(newData);
                console.log(`分析結果を保存しました: ${fileName}`);
            }
            
            localStorage.setItem(DB_KEY, JSON.stringify(db));
        }

        // --- ネットワーク図 制御 ---

        function showNetworkDiagram() {
            networkModal.classList.remove('invisible', 'opacity-0');
            networkModal.querySelector('.modal-content').classList.remove('scale-95');
            
            setTimeout(() => {
                drawNetworkDiagram();
            }, 50);

            nodeInfoDiv.innerHTML = '<p class="text-gray-500">ネットワーク図のノードをクリックすると、ここに要約が表示されます。</p>';
            downloadInfoButton.disabled = true;
            downloadInfoButton.dataset.fileName = "";
        }
        
        function hideNetworkDiagram() {
            networkModal.classList.add('invisible', 'opacity-0');
            networkModal.querySelector('.modal-content').classList.add('scale-95');
        }

        /**
         * ネットワーク図を描画（カテゴリ色分け修正済み）
         */
        function drawNetworkDiagram() {
            if (currentNetwork) {
                currentNetwork.destroy();
                currentNetwork = null;
            }
            networkDiagramDiv.innerHTML = '';

            if (typeof window.vis === 'undefined') {
                console.error("vis.js library is not loaded.");
                networkDiagramDiv.innerHTML = '<p class="p-4 text-red-500">エラー: ネットワークライブラリ(vis.js)の読み込みに失敗しました。</p>';
                return;
            }

            const db = loadDatabase();

            const stageOrder = ['Stage5', 'Stage4', 'Stage3', 'Stage2', 'Stage1', 'Unknown'];
            const categoryOrder = ['A', 'B', 'C', 'D', 'E', 'default', 'error'];

            // カテゴリ抽出関数
            const parseFileName = (fileName) => {
                const baseName = fileName.substring(0, fileName.lastIndexOf('.')) || fileName;
                const parts = baseName.split('_');
                
                let docId, year, stage, cat;

                if (parts.length >= 6) {
                    docId = parts[0] || baseName;
                    year = parts[1];
                    stage = parts[3].startsWith('Stage') ? parts[3].trim() : 'Unknown';
                    const rawCat = parts[4] ? parts[4].toUpperCase().trim() : 'default';
                    cat = categoryOrder.includes(rawCat) ? rawCat : 'default';
                } else {
                    docId = parts[0] || baseName;
                    year = 'Unknown';
                    stage = 'Unknown';
                    cat = 'error';
                }
                return { docId, year, stage, cat };
            };

            // 並び替え
            db.sort((a, b) => {
                const infoA = parseFileName(a.id);
                const infoB = parseFileName(b.id);
                
                if (infoA.year !== infoB.year) return infoA.year.localeCompare(infoB.year);
                if (infoA.stage !== infoB.stage) return stageOrder.indexOf(infoA.stage) - stageOrder.indexOf(infoB.stage);
                if (infoA.cat !== infoB.cat) return categoryOrder.indexOf(infoA.cat) - categoryOrder.indexOf(infoB.cat);
                return infoA.docId.localeCompare(infoB.docId);
            });

            if (db.length === 0) {
                networkDiagramDiv.innerHTML = '<p class="p-4 text-gray-500">保存されているデータがありません。</p>';
                return;
            }

            const nodes = [];
            const edges = [];
            
            const x_step = 250; 
            const y_stage_step = 150; 
            const y_cat_step = 100;
            const y_special_base = -300; // 特別ノードの最上部Y
            
            const yearMap = new Map();
            const analysisMap = new Map();
            
            const sortedYears = [...new Set(db.map(item => (item.id.split('_')[1] || 'Unknown')))].sort();
            sortedYears.forEach((year, index) => yearMap.set(year, index));

            // ノードデータ集約
            db.forEach(item => {
                const baseName = item.id.substring(0, item.id.lastIndexOf('.')) || item.id;
                const parts = baseName.split('_');
                
                let docId, year, prevDocIdsStr, stage, category;

                if (parts.length >= 6) {
                    docId = parts[0] || baseName;
                    year = parts[1];
                    prevDocIdsStr = parts[2];
                    stage = parts[3].startsWith('Stage') ? parts[3].trim() : 'Unknown';
                    const rawCat = parts[4] ? parts[4].toUpperCase().trim() : 'default';
                    category = categoryOrder.includes(rawCat) ? rawCat : 'default';
                } else {
                    docId = parts[0] || baseName;
                    year = 'Unknown';
                    prevDocIdsStr = '0000';
                    stage = 'Unknown';
                    category = 'error';
                }
                
                const isSpecial = item.id.includes('テーマ審議会') || item.id.includes('棚入れ');

                if (!analysisMap.has(docId)) {
                    analysisMap.set(docId, {
                        year: year,
                        category: category,
                        stage: stage,
                        files: [],
                        prevDocIdsStr: prevDocIdsStr,
                        isSpecial: isSpecial
                    });
                } else if (isSpecial) {
                    analysisMap.get(docId).isSpecial = true;
                }

                analysisMap.get(docId).files.push({
                    fileName: item.id,
                    analysis: item.analysis,
                    prevDocIdsStr: prevDocIdsStr
                });
            });

            // ノード作成
            const sortedNodesData = [...analysisMap.entries()].sort((a, b) => {
                const infoA = a[1];
                const infoB = b[1];
                if (infoA.year !== infoB.year) return infoA.year.localeCompare(infoB.year);
                if (infoA.stage !== infoB.stage) return stageOrder.indexOf(infoA.stage) - stageOrder.indexOf(infoB.stage);
                if (infoA.category !== infoB.category) return categoryOrder.indexOf(infoA.category) - categoryOrder.indexOf(infoB.category);
                return a[0].localeCompare(b[0]);
            });

            let yCounters = {};
            let ySpecialCounter = 0;

            sortedNodesData.forEach(([docId, data]) => {
                const x_index = yearMap.get(data.year) || 0;
                const x = x_index * x_step;
                let y;

                if (data.isSpecial) {
                    y = y_special_base - (ySpecialCounter * 100);
                    ySpecialCounter++;
                } else {
                    const y_stage_index = stageOrder.indexOf(data.stage);
                    const y_stage = y_stage_index * y_stage_step;

                    const y_cat_index = categoryOrder.indexOf(data.category);
                    const y_category = y_cat_index * y_cat_step;

                    const y_key = `${x_index}_${y_stage_index}_${y_cat_index}`;
                    if (!yCounters[y_key]) {
                        yCounters[y_key] = 0;
                    }
                    const y_offset = yCounters[y_key] * 100; 
                    yCounters[y_key]++;

                    y = y_stage + y_category + y_offset;
                }

                const fileTitles = data.files.map(f => f.fileName).join('\n');

                nodes.push({
                    id: docId,
                    label: `${docId}\n(${data.category} / ${data.stage} / ${data.year})`, 
                    title: fileTitles,
                    group: data.category || 'default', // ← グループ名を明示
                    x: x,
                    y: y,
                    fixed: true
                });
            });

            // エッジ作成
            const addedEdges = new Set();
            db.forEach(item => {
                const baseName = item.id.substring(0, item.id.lastIndexOf('.')) || item.id;
                const parts = baseName.split('_');
                
                const currentNodeDocId = parts[0];
                let prevDocIdsStr = (parts.length >= 6) ? parts[2] : '0000';

                if (prevDocIdsStr !== '0000') {
                    const parentDocIds = prevDocIdsStr.split('AND');
                    parentDocIds.forEach(parentId => {
                        parentId = parentId.trim();
                        if (parentId && analysisMap.has(parentId)) {
                            const edgeId = `${parentId}->${currentNodeDocId}`;
                            if (!addedEdges.has(edgeId)) {
                                edges.push({
                                    from: parentId,
                                    to: currentNodeDocId,
                                    arrows: "to",
                                    color: { color: '#9CA3AF', highlight: '#2563EB' }
                                });
                                addedEdges.add(edgeId);
                            }
                        }
                    });
                }
            });

            // ★★ 修正ポイント：グループ色は color オブジェクトの下に置く ★★
            const groupColors = {
                'A': { color: { background: '#FFF59D', border: '#FBC02D',
                        highlight: { background: '#FFE082', border: '#F9A825' },
                        hover: { background: '#FFF59D', border: '#FBC02D' } } },
                'B': { color: { background: '#A5D6A7', border: '#43A047',
                        highlight: { background: '#C8E6C9', border: '#2E7D32' },
                        hover: { background: '#A5D6A7', border: '#43A047' } } },
                'C': { color: { background: '#90CAF9', border: '#1E88E5',
                        highlight: { background: '#BBDEFB', border: '#1565C0' },
                        hover: { background: '#90CAF9', border: '#1E88E5' } } },
                'D': { color: { background: '#CE93D8', border: '#8E24AA',
                        highlight: { background: '#E1BEE7', border: '#6A1B9A' },
                        hover: { background: '#CE93D8', border: '#8E24AA' } } },
                'E': { color: { background: '#F48FB1', border: '#D81B60',
                        highlight: { background: '#F8BBD0', border: '#AD1457' },
                        hover: { background: '#F48FB1', border: '#D81B60' } } },
                'default': { color: { background: '#B0BEC5', border: '#546E7A',
                        highlight: { background: '#CFD8DC', border: '#37474F' },
                        hover: { background: '#B0BEC5', border: '#546E7A' } } },
                'error': { color: { background: '#FFAB91', border: '#E64A19',
                        highlight: { background: '#FFCCBC', border: '#BF360C' },
                        hover: { background: '#FFAB91', border: '#E64A19' } } }
            };

            const data = { nodes: nodes, edges: edges };
            const options = {
                physics: false,
                layout: { hierarchical: false },
                nodes: {
                    shape: "box",
                    size: 10,
                    margin: 10,
                    font: { size: 14, color: "#333" },
                    borderWidth: 2,
                    shadow: true
                },
                // ここでグループ色を適用
                groups: groupColors,
                interaction: {
                    dragNodes: true,
                    dragView: true,
                    zoomView: true,
                    hover: true
                },
                // ★★ 修正：edges の二重ネストを解消し、色継承も無効化 ★★
                edges: {
                    smooth: {
                        type: 'cubicBezier',
                        forceDirection: "horizontal",
                        roundness: 0.1
                    },
                    color: {
                        inherit: false
                    }
                }
            };

            currentNetwork = new window.vis.Network(networkDiagramDiv, data, options);

            currentNetwork.on("click", function(params) {
                if (params.nodes.length > 0) {
                    const nodeId = params.nodes[0];
                    const nodeData = analysisMap.get(nodeId);
                    
                    if (nodeData) {
                        let infoHtml = '';
                        let textToSave = '';

                        nodeData.files.forEach(file => {
                            const analysisText = file.analysis;
                            const pointsMatch = analysisText.match(/【技術の棚入れ \(重要ポイント\)】([\s\S]*)/);
                            const importantPoints = pointsMatch ? pointsMatch[1].trim() : '重要ポイントがありません。';

                            infoHtml += `<div class="node-info-block">
                                           <h4 class="node-info-header">${file.fileName}</h4>
                                           <div class="node-info-content">${importantPoints}</div>
                                         </div>`;
                            
                            textToSave += `■ ${file.fileName}\n${importantPoints}\n\n`;
                        });

                        nodeInfoDiv.innerHTML = infoHtml;
                        downloadInfoButton.disabled = false;
                        downloadInfoButton.dataset.fileName = nodeId; 
                        downloadInfoButton.dataset.text = textToSave;

                    } else {
                        nodeInfoDiv.innerHTML = '<p class="text-gray-500">ノード情報の取得に失敗しました。</p>';
                        downloadInfoButton.disabled = true;
                    }
                } else {
                    nodeInfoDiv.innerHTML = '<p class="text-gray-500">ネットワーク図のノードをクリックすると、ここに要約が表示されます。</p>';
                    downloadInfoButton.disabled = true;
                }
            });
        }

        // --- JPEGダウンロード / 履歴削除機能 ---
        async function downloadNetworkAsJPEG() {
            if (!currentNetwork) return;

            const canvas = networkDiagramDiv.querySelector('canvas');
            if (!canvas) {
                console.error("Canvasが見つかりません。");
                return;
            }
            
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = canvas.width;
            offscreenCanvas.height = canvas.height;
            const ctx = offscreenCanvas.getContext('2d');
            
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            ctx.drawImage(canvas, 0, 0);

            const dataURL = offscreenCanvas.toDataURL("image/jpeg", 0.9);

            const link = document.createElement('a');
            link.href = dataURL;
            link.download = 'document_network_diagram.jpeg';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function downloadNodeInfo() {
            const textToSave = downloadInfoButton.dataset.text;
            const baseFileName = downloadInfoButton.dataset.fileName || "node_info";
            
            if (!textToSave) {
                console.warn("保存するテキストがありません。");
                return;
            }

            let safeFileName = baseFileName.replace(/[^a-z0-9_AND-]/gi, '-');
            const fileName = `${safeFileName}_important_points.txt`;

            try {
                const blob = new Blob([textToSave], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            } catch (e) {
                console.error("テキストファイルのダウンロードに失敗しました:", e);
            }
        }

    </script>
</body>
</html>
